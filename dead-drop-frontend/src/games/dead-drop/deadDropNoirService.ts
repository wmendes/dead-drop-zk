/**
 * Dead Drop Noir Proof Service
 *
 * Client-side ZK proof generation using NoirJS + bb.js (UltraHonk).
 *
 * Commitment = Poseidon2(x, y, salt)  (via Barretenberg WASM)
 * Circuit verifies (hidden-drop design):
 *   1. Poseidon2(drop_x, drop_y, drop_salt) === expected_commitment
 *   2. wrappedManhattan(ping_x, ping_y, drop_x, drop_y) === expected_distance
 */

import { Noir } from '@noir-lang/noir_js';
import { UltraHonkBackend } from '@aztec/bb.js';
import { poseidon2Hash } from '@zkpassport/poseidon2';

// The compiled Noir circuit artifact (JSON).
// Generated by `nargo compile`, placed in circuits/dead_drop/target/dead_drop.json.
// Vite resolves this import at build time.
// @ts-ignore — JSON import resolved by Vite
import circuit from '../../../../circuits/dead_drop/target/dead_drop.json';

const GRID_SIZE = 100;

// BN254 scalar field prime (Fq).
// All field inputs to Noir / Poseidon2 must be in [0, BN254_FR).
// A random 32-byte salt has ~81 % chance of exceeding this bound, so we always
// reduce mod p before using the salt as a witness or hash input.
const BN254_FR = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;

export interface NoirProofResult {
    distance: number;
    proofHex: string;
    publicInputsHex: string[];
}

export interface NoirProvePingInput {
    sessionId: number;
    turn: number;
    pingX: number;
    pingY: number;
    // Hidden drop private inputs
    dropX: number;
    dropY: number;
    dropSalt: Uint8Array;
    dropCommitment: string; // hex, 32 bytes
}

// ============================================================================
// Singleton instances (lazily initialized)
// ============================================================================

let noirInstance: Noir | null = null;
let backendInstance: UltraHonkBackend | null = null;

async function getNoirAndBackend(): Promise<{ noir: Noir; backend: UltraHonkBackend }> {
    if (!noirInstance || !backendInstance) {
        backendInstance = new UltraHonkBackend((circuit as any).bytecode);
        noirInstance = new Noir(circuit as any);
    }
    return { noir: noirInstance, backend: backendInstance };
}

// ============================================================================
// Utility functions
// ============================================================================

/** Wrapped Manhattan distance on a 100×100 toroidal grid. */
function wrappedManhattan(ax: number, ay: number, bx: number, by: number): number {
    const dx = Math.abs(ax - bx);
    const dy = Math.abs(ay - by);
    return Math.min(dx, GRID_SIZE - dx) + Math.min(dy, GRID_SIZE - dy);
}

/** Convert a 32-byte salt to a hex-prefixed string for Noir field input. */
function toFieldHex(value: bigint | number): string {
    return '0x' + BigInt(value).toString(16).padStart(64, '0');
}

/** Convert a Uint8Array (32 bytes) to a bigint. */
function bytesToBigInt(bytes: Uint8Array): bigint {
    let result = 0n;
    for (const b of bytes) {
        result = (result << 8n) | BigInt(b);
    }
    return result;
}

// ============================================================================
// Poseidon2 commitment (matches Noir circuit exactly)
// ============================================================================

/**
 * Compute Poseidon2 commitment using pure-JS BN254 implementation.
 * Uses the same sponge construction as Noir's poseidon2_permutation:
 *   IV = input_len * 2^64, absorb all fields, squeeze once.
 *
 * Returns the commitment as a lowercase hex string (64 chars, no 0x prefix).
 */
export async function computeCommitmentNoir(
    x: number,
    y: number,
    salt: Uint8Array,
): Promise<string> {
    const xBig = BigInt(x);
    const yBig = BigInt(y);
    const saltBig = bytesToBigInt(salt) % BN254_FR;

    // poseidon2Hash from @zkpassport/poseidon2 uses fixed-length sponge
    // with IV = (input.length << 64), matching our Noir circuit exactly.
    const result = poseidon2Hash([xBig, yBig, saltBig]);
    return result.toString(16).padStart(64, '0');
}

// ============================================================================
// Proof generation
// ============================================================================

/**
 * Generate a ZK proof for a ping using the Noir circuit.
 * Runs entirely in the browser via WASM.
 *
 * The backend prover generates this proof using:
 * - hidden drop witness (x, y, salt)
 * - public ping coordinates
 */
export async function provePingNoir(input: NoirProvePingInput): Promise<NoirProofResult> {
    const { noir, backend } = await getNoirAndBackend();

    const distance = wrappedManhattan(
        input.pingX,
        input.pingY,
        input.dropX,
        input.dropY,
    );

    const dropSaltBigInt = bytesToBigInt(input.dropSalt) % BN254_FR;

    // Prepare witness inputs matching the Noir circuit's main() parameters.
    // Noir field inputs accept hex strings or decimal strings.
    const witnessInputNew = {
        // Private inputs
        drop_x: input.dropX.toString(),
        drop_y: input.dropY.toString(),
        drop_salt: toFieldHex(dropSaltBigInt),
        // Public inputs
        session_id: input.sessionId.toString(),
        turn: input.turn.toString(),
        ping_x: input.pingX.toString(),
        ping_y: input.pingY.toString(),
        expected_commitment: '0x' + input.dropCommitment.replace(/^0x/, ''),
        expected_distance: distance.toString(),
    };

    // Legacy naming fallback for old circuit artifacts.
    const witnessInputLegacy = {
        // Private inputs
        responder_x: input.dropX.toString(),
        responder_y: input.dropY.toString(),
        responder_salt: toFieldHex(dropSaltBigInt),
        // Public inputs
        session_id: input.sessionId.toString(),
        turn: input.turn.toString(),
        partial_dx: input.pingX.toString(),
        partial_dy: input.pingY.toString(),
        expected_commitment: '0x' + input.dropCommitment.replace(/^0x/, ''),
        expected_distance: distance.toString(),
    };

    // Generate witness + prove
    let witness: Uint8Array;
    try {
        ({ witness } = await noir.execute(witnessInputNew));
    } catch (newSchemaErr) {
        try {
            ({ witness } = await noir.execute(witnessInputLegacy));
        } catch {
            throw newSchemaErr;
        }
    }
    const proof = await backend.generateProof(witness);

    // Extract proof bytes and public inputs as hex strings
    const proofHex = Buffer.from(proof.proof).toString('hex');
    const publicInputsHex = proof.publicInputs.map((pi: string) => {
        // Public inputs from bb.js are hex-encoded 32-byte field elements
        const cleaned = pi.startsWith('0x') ? pi.slice(2) : pi;
        return cleaned.padStart(64, '0');
    });

    return {
        distance,
        proofHex,
        publicInputsHex,
    };
}

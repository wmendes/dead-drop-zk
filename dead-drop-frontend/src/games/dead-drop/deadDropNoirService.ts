/**
 * Dead Drop Noir Proof Service
 *
 * Client-side ZK proof generation using NoirJS + bb.js (UltraHonk).
 *
 * Commitment = Poseidon2(x, y, salt)  (via Barretenberg WASM)
 * Circuit verifies (nuclear-keys responder design):
 *   1. Poseidon2(responder_x, responder_y, responder_salt) === expected_commitment
 *   2. wrappedManhattan(partial_dx, partial_dy, responder_x, responder_y) === expected_distance
 */

import { Noir } from '@noir-lang/noir_js';
import { UltraHonkBackend } from '@aztec/bb.js';
import { poseidon2Hash } from '@zkpassport/poseidon2';

// The compiled Noir circuit artifact (JSON).
// Generated by `nargo compile`, placed in circuits/dead_drop/target/dead_drop.json.
// Vite resolves this import at build time.
// @ts-ignore — JSON import resolved by Vite
import circuit from '../../../../circuits/dead_drop/target/dead_drop.json';

const GRID_SIZE = 100;

// BN254 scalar field prime (Fq).
// All field inputs to Noir / Poseidon2 must be in [0, BN254_FR).
// A random 32-byte salt has ~81 % chance of exceeding this bound, so we always
// reduce mod p before using the salt as a witness or hash input.
const BN254_FR = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;

export interface NoirProofResult {
    distance: number;
    proofHex: string;
    publicInputsHex: string[];
}

export interface NoirProvePingInput {
    sessionId: number;
    turn: number;
    partialDx: number;
    partialDy: number;
    // Responder private inputs
    responderX: number;
    responderY: number;
    responderSalt: Uint8Array;
    responderCommitment: string; // hex, 32 bytes
}

// ============================================================================
// Singleton instances (lazily initialized)
// ============================================================================

let noirInstance: Noir | null = null;
let backendInstance: UltraHonkBackend | null = null;

async function getNoirAndBackend(): Promise<{ noir: Noir; backend: UltraHonkBackend }> {
    if (!noirInstance || !backendInstance) {
        backendInstance = new UltraHonkBackend((circuit as any).bytecode);
        noirInstance = new Noir(circuit as any);
    }
    return { noir: noirInstance, backend: backendInstance };
}

// ============================================================================
// Utility functions
// ============================================================================

/** Wrapped Manhattan distance on a 100×100 toroidal grid. */
function wrappedManhattan(ax: number, ay: number, bx: number, by: number): number {
    const dx = Math.abs(ax - bx);
    const dy = Math.abs(ay - by);
    return Math.min(dx, GRID_SIZE - dx) + Math.min(dy, GRID_SIZE - dy);
}

/** Convert a 32-byte salt to a hex-prefixed string for Noir field input. */
function toFieldHex(value: bigint | number): string {
    return '0x' + BigInt(value).toString(16).padStart(64, '0');
}

/** Convert a Uint8Array (32 bytes) to a bigint. */
function bytesToBigInt(bytes: Uint8Array): bigint {
    let result = 0n;
    for (const b of bytes) {
        result = (result << 8n) | BigInt(b);
    }
    return result;
}

// ============================================================================
// Poseidon2 commitment (matches Noir circuit exactly)
// ============================================================================

/**
 * Compute Poseidon2 commitment using pure-JS BN254 implementation.
 * Uses the same sponge construction as Noir's poseidon2_permutation:
 *   IV = input_len * 2^64, absorb all fields, squeeze once.
 *
 * Returns the commitment as a lowercase hex string (64 chars, no 0x prefix).
 */
export async function computeCommitmentNoir(
    x: number,
    y: number,
    salt: Uint8Array,
): Promise<string> {
    const xBig = BigInt(x);
    const yBig = BigInt(y);
    const saltBig = bytesToBigInt(salt) % BN254_FR;

    // poseidon2Hash from @zkpassport/poseidon2 uses fixed-length sponge
    // with IV = (input.length << 64), matching our Noir circuit exactly.
    const result = poseidon2Hash([xBig, yBig, saltBig]);
    return result.toString(16).padStart(64, '0');
}

// ============================================================================
// Proof generation
// ============================================================================

/**
 * Generate a ZK proof for a ping using the Noir circuit.
 * Runs entirely in the browser via WASM.
 *
 * The responder generates this proof using only:
 * - their own secret share
 * - partial offsets sent by the pinger
 */
export async function provePingNoir(input: NoirProvePingInput): Promise<NoirProofResult> {
    const { noir, backend } = await getNoirAndBackend();

    const distance = wrappedManhattan(
        input.partialDx,
        input.partialDy,
        input.responderX,
        input.responderY,
    );

    const responderSaltBigInt = bytesToBigInt(input.responderSalt) % BN254_FR;

    // Prepare witness inputs matching the Noir circuit's main() parameters.
    // Noir field inputs accept hex strings or decimal strings.
    const witnessInput = {
        // Private inputs
        responder_x: input.responderX.toString(),
        responder_y: input.responderY.toString(),
        responder_salt: toFieldHex(responderSaltBigInt),
        // Public inputs
        session_id: input.sessionId.toString(),
        turn: input.turn.toString(),
        partial_dx: input.partialDx.toString(),
        partial_dy: input.partialDy.toString(),
        expected_commitment: '0x' + input.responderCommitment.replace(/^0x/, ''),
        expected_distance: distance.toString(),
    };

    // Generate witness + prove
    const { witness } = await noir.execute(witnessInput);
    const proof = await backend.generateProof(witness);

    // Extract proof bytes and public inputs as hex strings
    const proofHex = Buffer.from(proof.proof).toString('hex');
    const publicInputsHex = proof.publicInputs.map((pi: string) => {
        // Public inputs from bb.js are hex-encoded 32-byte field elements
        const cleaned = pi.startsWith('0x') ? pi.slice(2) : pi;
        return cleaned.padStart(64, '0');
    });

    return {
        distance,
        proofHex,
        publicInputsHex,
    };
}
